###### 右值引用&左值引用
* 右值引用——必须绑定到右值的引用，重要特性：只能绑定到一个将要销毁的对象。
  左值表达式表示的是一个对象的身份(在内存中的位置)，右值表达式表示对象的值(对象的内容)
* 左值引用——不能绑定到要求转换的表达式，字面常量或者返回右值的表达式
* 返回左值引用的函数，赋值，下标，解引用和前置递增/递减运算符都是左值。
  返回非引用类型的函数，算术，关系，位，以及后置递增/递减运算符都生成右值。
  不能将左值引用绑定到返回非引用类型的表达式，但可以将const的左值引用或者右值引用绑定这类表达式上。

###### move函数
* int &&rr3=std::move(rr1); 把一个左值转换成右值引用
* rr1 是移后源对象，可以销毁一个移后源对象，也可以对它赋值，但是不能使用它的值。

###### 移动构造函数和移动赋值运算符
* 移动构造函数完成资源移动，源对象必须不再指向被移动的资源，这些资源所有权已经归属新创建的对象，
  与拷贝构造函数不同，移动构造函数不分配任何新的内存，它接管给定对象中的内存，将给定对象中的指针置nullptr.
* 移动赋值运算符，释放左侧运算对象的内存，接管给定对象的内存,将给定对象中的指针置nullptr.
* 移后源对象必须可析构，而且是有效的(可以安全地赋新值或者可以安全的使用而不依赖其当前值)

###### 合成的移动操作
* 如果一个类有自定义拷贝构造函数，拷贝赋值运算符或者析构函数，编译器就不会合成移动构造函数和移动赋值运算符，
  如果一个类没有移动操作，通过函数匹配，类会通过对应的拷贝操作来代替移动操作。
* 生成合成移动操作条件：
  >1. 类没有定义任何自己版本的拷贝控制成员。
 
  >2. 它的所有数据成员都具有移动操作。

* 与拷贝操作不同，移动操作永远不会隐式定义为删除的函数。如果我们显示定义一个=default() 移动操作，
  但该类不能移动所有成员，则编译器会将移动操作定义为删除的函数。
* 移动操作函数被定义为删除的原则：

  >1. 定义了拷贝构造函数，但移动构造函数未定义或者未定义拷贝构造函数，但编译器不能合成移动构造函数,移动赋值运算符也一样。
  
  >2. 如果类成员的移动操作被定义为删除的或者不可访问的，则类自己的移动操作被定义为删除的。

  >3. 类似拷贝构造函数，如果类的析构函数被定义为删除的或者不可访问的，则类的移动构造函数被定义为删除的。

  >4. 类似拷贝赋值运算符，如果有类的成员const的或者是引用，则类的移动赋值运算符被定义为删除的。
  
  >5. 如果类定义了移动操作，则该类的合成拷贝操作定义为删除的。如想使用拷贝操作，需要自定义。

###### 移动右值，拷贝左值
```c++
	StrVec v1,v2;
	v1=v2;  //v2是左值使用拷贝赋值
	StrVec get();//返回非引用类型的函数作为右值
	v2=get(); 
	移动赋值运算符参数类型是非常量(StrVec&)，拷贝赋值运算参数类型是常量(const StrVec&)，
	两个都可以匹配,但get()的最匹配规则是非常量。
```

