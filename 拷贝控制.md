###### 右值引用&左值引用
* 右值引用——必须绑定到右值的引用，重要特性：只能绑定到一个将要销毁的对象。
  左值表达式表示的是一个对象的身份(在内存中的位置)，右值表达式表示对象的值(对象的内容)
* 左值引用——不能绑定到要求转换的表达式，字面常量或者返回右值的表达式
* 返回左值引用的函数，赋值，下标，解引用和前置递增/递减运算符都是左值。
  返回非引用类型的函数，算术，关系，位，以及后置递增/递减运算符都生成右值。
  不能将左值引用绑定到返回非引用类型的表达式，但可以将const的左值引用或者右值引用绑定这类表达式上。

###### move函数
* int &&rr3=std::move(rr1); move返回一个绑定到rr1的右值引用。
* rr1 是移后源对象，可以销毁一个移后源对象，也可以对它赋值，但是不能使用它的值。

###### 移动构造函数和移动赋值运算符
* 移动构造函数完成资源移动，源对象必须不再指向被移动的资源，这些资源所有权已经归属新创建的对象，
  与拷贝构造函数不同，移动构造函数不分配任何新的内存，它接管给定对象中的内存，将给定对象中的指针置nullptr.
* 移动赋值运算符，释放左侧运算对象的内存，接管给定对象的内存,将给定对象中的指针置nullptr.
* 移后源对象必须可析构，而且是有效的(可以安全地赋新值或者可以安全的使用而不依赖其当前值)

###### 合成的移动操作
* 如果一个类有自定义拷贝构造函数，拷贝赋值运算符或者析构函数，编译器就不会合成移动构造函数和移动赋值运算符，
  如果一个类没有移动操作，通过函数匹配，类会通过对应的拷贝操作来代替移动操作。
* 生成合成移动操作条件：
  >1. 类没有定义任何自己版本的拷贝控制成员。
 
  >2. 它的所有数据成员都具有移动操作。

* 与拷贝操作不同，移动操作永远不会隐式定义为删除的函数。如果我们显示定义一个=default() 移动操作，
  但该类不能移动所有成员，则编译器会将移动操作定义为删除的函数。
* 移动操作函数被定义为删除的原则：

  >1. 定义了拷贝构造函数，但移动构造函数未定义或者未定义拷贝构造函数，但编译器不能合成移动构造函数,移动赋值运算符也一样。
  
  >2. 如果类成员的移动操作被定义为删除的或者不可访问的，则类自己的移动操作被定义为删除的。

  >3. 类似拷贝构造函数，如果类的析构函数被定义为删除的或者不可访问的，则类的移动构造函数被定义为删除的。

  >4. 类似拷贝赋值运算符，如果有类的成员const的或者是引用，则类的移动赋值运算符被定义为删除的。
  
  >5. 如果类定义了移动操作，则该类的合成拷贝操作定义为删除的。如想使用拷贝操作，需要自定义。

###### 移动右值，拷贝左值
```c++
	StrVec v1,v2;
	v1=v2;  //v2是左值使用拷贝赋值
	StrVec get();//返回非引用类型的函数作为右值
	v2=get(); 
	移动赋值运算符参数类型是非常量(StrVec&)，拷贝赋值运算参数类型是常量(const StrVec&)，
	两个都可以匹配,但get()返回的是非常量类型。
```
* 如果一个类定义了拷贝构造函数，但未定义移动构造函数，如果试图用move移动操作，则对象是通过拷贝构造函数来"移动"的，
  拷贝赋值和移动赋值类似。

###### 拷贝并交换赋值运算符和移动操作
```c++
class HasPtr {
   public:
     HasPtr(HasPtr &&p) noexcept :ps(p.ps),i(p.i) {p.ps=0;}
     
     HasPtr& operator=(HasPtr rhs) 
          {
                    swap(*this,rhs); return *this;
          }
}

hp = hp2；
hp = std::move(hp2);
由于赋值运算符参数是非引用类型，会进行拷贝初始化(拷贝构造或者移动构造)，左值被拷贝，右值被移动,
第一个赋值中，hp2是左值，左值使用拷贝构造函数初始化，拷贝构造函数分配新的string并拷贝hp2指向的string

第二个赋值中，由于move返回一个绑定到hp2的右值引用，当前定义的实参是一个右值引用，因此通过移动构造函数初始化，
移动构造函数从hp2拷贝指针，而不会分配任何内存。
此赋值运算符接受拷贝和移动赋值运算，交换HasPtr会交换两个对象的指针和其他成员，在swap后rhs中的指针将指向原来左侧运算对象所拥有的数据，当rhs离开作用域，这个数据将被销毁。0

```












